/**
 * Copyright 2012 Matt Corallo
 * Copyright 2014 Andreas Schildbach
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.spreadcoinj.core;

import org.junit.Ignore;
import org.spreadcoinj.core.TransactionConfidence.ConfidenceType;
import org.spreadcoinj.params.UnitTestParams;
import org.spreadcoinj.store.MemoryBlockStore;
import org.spreadcoinj.testing.FakeTxBuilder;
import org.spreadcoinj.testing.InboundMessageQueuer;
import org.spreadcoinj.testing.TestWithPeerGroup;
import org.spreadcoinj.wallet.KeyChainGroup;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;

import java.math.BigInteger;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.Set;

import static org.spreadcoinj.core.Utils.HEX;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

@RunWith(value = Parameterized.class)
public class FilteredBlockAndPartialMerkleTreeTests extends TestWithPeerGroup {
    @Parameterized.Parameters
    public static Collection<ClientType[]> parameters() {
        return Arrays.asList(new ClientType[] {ClientType.NIO_CLIENT_MANAGER},
                             new ClientType[] {ClientType.BLOCKING_CLIENT_MANAGER});
    }

    public FilteredBlockAndPartialMerkleTreeTests(ClientType clientType) {
        super(clientType);
    }

    @Test
    public void deserializeFilteredBlock() throws Exception {
        NetworkParameters params = UnitTestParams.get();

        // Random real block (000000000000dab0130bbcc991d3d7ae6b81aa6f50a798888dfe62337458dc45)
        // With one tx
        FilteredBlock block = new FilteredBlock(params, HEX.decode("020000006d3452d63919910899af689cfbef2f2255dc1a97ab7e3f1bd3a97a35711667246b0634c0762c7807ac5af33eb61a1933add6d40d021b722edbee8d918159e56c8db94654000000005acc0f1da58601009bd30100dd12b5eea7842e798719266c196461df589407caf676c613dbaa4d9e0cd2e81e1b5bfbb2a0896f242ded8d0ded54b3d98ec12d34483446b2146fa50fa969261d1b063976835759456fef859eaf1c75915d5628e6d58515f4582662c813faafc6ee01000000016b0634c0762c7807ac5af33eb61a1933add6d40d021b722edbee8d918159e56c0101"));
        
        // Check that the header was properly deserialized
        assertTrue(block.getBlockHeader().getHash().equals(new Sha256Hash("7bc2582c7aa1d21ce3df89f1ed1b2061134e6fc6d42e0d3a8b4d9d030b0e815b")));
        
        // Check that the partial merkle tree is correct
        List<Sha256Hash> txesMatched = block.getTransactionHashes();
        assertTrue(txesMatched.size() == 1);
        assertTrue(txesMatched.contains(new Sha256Hash("6ce55981918deedb2e721b020dd4d6ad33191ab63ef35aac07782c76c034066b")));

        // Check round tripping.
        assertEquals(block, new FilteredBlock(params, block.bitcoinSerialize()));
    }

    @Test
    public void createFilteredBlock() throws Exception {
        ECKey key1 = new ECKey();
        ECKey key2 = new ECKey();
        Transaction tx1 = FakeTxBuilder.createFakeTx(params, Coin.COIN,  key1);
        Transaction tx2 = FakeTxBuilder.createFakeTx(params, Coin.FIFTY_COINS, key2.toAddress(params));
        Block block = FakeTxBuilder.makeSolvedTestBlock(params.getGenesisBlock(), new Address(params, "msg2t2V2sWNd85LccoddtWysBTR8oPnkzW"), tx1, tx2);
        BloomFilter filter = new BloomFilter(4, 0.1, 1);
        filter.insert(key1);
        filter.insert(key2);
        FilteredBlock filteredBlock = filter.applyAndUpdate(block);
        assertEquals(4, filteredBlock.getTransactionCount());
        // This call triggers verification of the just created data.
        List<Sha256Hash> txns = filteredBlock.getTransactionHashes();
        assertTrue(txns.contains(tx1.getHash()));
        assertTrue(txns.contains(tx2.getHash()));
    }

    @Ignore
    @Test
    public void serializeDownloadBlockWithWallet() throws Exception {
        unitTestParams = UnitTestParams.get();
        
        // First we create all the neccessary objects, including lots of serialization and double-checks
        // Note that all serialized forms here are generated by the reference client/pulled from block explorer
        Block block = new Block(unitTestParams, HEX.decode("02000000dcb5056192d660134e731960cbebfeee9a34e539c7599839c2d7b77e4e899f6ef8ec148bbe2a09310e5d35ddb562ffc5a15a12331320ce78bff329aa8a860935cade4a5400000000d2c40a1d92980100f02b0000ccc6d6e86e1af70c861da17e91f3a1cdd84ca7fbff88d308e2d0c29f779449511bcc400458af93be5d6c2921ba1d5addbc622ea4a14871466e5f82e38f71c8b550d2f7a9a405de56787db803d28fb924925d7c4166e02b40adbf1623ada677717e0501000000010000000000000000000000000000000000000000000000000000000000000000ffffffff020102ffffffff01c4a2b826000000001614e484ff87e2a1c8c0f78a3f9e95bf6529e35a2000ac000000000100000001c5a1966856ebbe10d3b825de2511ef9584ad8ef7a98658dc888bdf44e5afcbf80000000043421b171291ff7845efb6c7aa1c34b65e0b30c3fe727007c1047448ba5361c252af344ba3ee581d38f48b80c5ad4c48a4dd317bbfe7d488ca555f06ea06e8e9d68a9301ffffffff0280a34cee00000000161418552af07934b3ff02aed2a5899d214cc55d5f89ace0fd1c00000000001614d5acf11cd24d4d28f09216c043d64f3f199497efac000000000100000001db9ad6d0583783f7cc29a33884bd302c6af04199ca5d26f6904b1dfdff60266e0000000043421bf4a47d7a21190a177d94e1a3cc2e9037da60ba049735562beff2a549f8c1ed1eb71aae8ccbefe11bd50443b49e8ac95f220a87a4cb03d33dea2a38758d39b1d101ffffffff0280a34cee00000000161418552af07934b3ff02aed2a5899d214cc55d5f89ace0fd1c00000000001614546b7b1ae89d28f2379f02897580b5a0d771b1c4ac00000000010000000230a5d72d394eb64ddac0a27c7bc2ddab20fb0c3edfeea17a91bfe8b6b0c37b070100000043421ce661e84764c870ea66bd63d98b7e37ffbadd6df24ab3363cfb8a1a390754a5f127fb508e58764b81836687c8e23fe7ce61d0ef459d8e786d343b4e7835d0c05201ffffffff7ce1eb467082149ef38597024d061ac104397d43179cdcfdadf1febb337849cd0000000043421b394aea6661131698f85a315372a09696f0a104c6faa33265ae3633fffa1e8be8d1acc67e4324fa4b4e5519a25f3dd011545c7f24acbb41c4bbcc513f2169070901ffffffff0280a34cee00000000161418552af07934b3ff02aed2a5899d214cc55d5f89ac09a11100000000001614cbcda734e2d2784eab38d2ec42ecbf17ace008f4ac000000000100000002baf3db1463b0a4e194069a05a91abeb3c7d03c5ac3c7199405e7cf165af574730000000043421b4811e8187b826df6af5b78eb58abd87d0694315bfc78c49c3da6bf19fe74beea6423aba4aa66e1bbf4a1e6b400e83070eabc3428ffca6acb5ddae00fe3c07e1801ffffffff9358a356cf8b822027e40ffe2a1b3e4226b01851324c9a3aea00984da56bee970100000043421cec95d242a413215dc8356bc0553f89dd6458cb6682e20cc0bd3968d2b8233d406128156ff4eb63c07ffeeee30d7337ab4e583b4d6732ec390600307da4dda1ff01ffffffff02468c1b0000000000161455372fce5ae532ba82d57841c6c0509fcd32db75ac80a34cee00000000161418552af07934b3ff02aed2a5899d214cc55d5f89ac00000000"));
        FilteredBlock filteredBlock = new FilteredBlock(unitTestParams, HEX.decode("02000000dcb5056192d660134e731960cbebfeee9a34e539c7599839c2d7b77e4e899f6ef8ec148bbe2a09310e5d35ddb562ffc5a15a12331320ce78bff329aa8a860935cade4a5400000000d2c40a1d92980100f02b0000ccc6d6e86e1af70c861da17e91f3a1cdd84ca7fbff88d308e2d0c29f779449511bcc400458af93be5d6c2921ba1d5addbc622ea4a14871466e5f82e38f71c8b550d2f7a9a405de56787db803d28fb924925d7c4166e02b40adbf1623ada677717e05000000040d7000db48cb5577b1ac27d823dc204b1476db5844246bf61328112f259f445bc073a38c38cbf14a96abe8cc225b9181609cc8134dcf1cbb87107f7f7630942b2587642b2aadf8b430a9162aadba3f80fe03bc9cf62db996a304d339943cb9bec3edfe5656380da2eb111d17efad47fb9db960b821282fe56f6d7448cb30686302df01"));
        
        // Block 104594
        assertTrue(block.getHash().equals(new Sha256Hash("2ad9653770fd5239072ab94282a39fff63f63ec184a431a12ab673a6228d5324")));
        assertTrue(filteredBlock.getHash().equals(block.getHash()));
        
        List<Sha256Hash> txHashList = filteredBlock.getTransactionHashes();
        assertTrue(txHashList.size() == 3);
        // Three transactions (0, 1, 4) from block 104594
        Transaction tx0 = new Transaction(unitTestParams, HEX.decode("01000000010000000000000000000000000000000000000000000000000000000000000000ffffffff020102ffffffff01c4a2b826000000001614e484ff87e2a1c8c0f78a3f9e95bf6529e35a2000ac00000000"));
        assertTrue(tx0.getHash().equals(new Sha256Hash("5b449f252f112813f66b244458db76144b20dc23d827acb17755cb48db00700d")));
        assertEquals(tx0.getHash(), txHashList.get(0));
        
        Transaction tx1 = new Transaction(unitTestParams, HEX.decode("0100000001c5a1966856ebbe10d3b825de2511ef9584ad8ef7a98658dc888bdf44e5afcbf80000000043421b171291ff7845efb6c7aa1c34b65e0b30c3fe727007c1047448ba5361c252af344ba3ee581d38f48b80c5ad4c48a4dd317bbfe7d488ca555f06ea06e8e9d68a9301ffffffff0280a34cee00000000161418552af07934b3ff02aed2a5899d214cc55d5f89ace0fd1c00000000001614d5acf11cd24d4d28f09216c043d64f3f199497efac00000000"));
        assertTrue(tx1.getHash().equals(new Sha256Hash("2b9430767f7f1087bb1ccf4d13c89c6081915b22cce8ab964af1cb388ca373c0")));
        assertEquals(tx1.getHash(), txHashList.get(1));

        Transaction tx2 = new Transaction(unitTestParams, HEX.decode("0100000002baf3db1463b0a4e194069a05a91abeb3c7d03c5ac3c7199405e7cf165af574730000000043421b4811e8187b826df6af5b78eb58abd87d0694315bfc78c49c3da6bf19fe74beea6423aba4aa66e1bbf4a1e6b400e83070eabc3428ffca6acb5ddae00fe3c07e1801ffffffff9358a356cf8b822027e40ffe2a1b3e4226b01851324c9a3aea00984da56bee970100000043421cec95d242a413215dc8356bc0553f89dd6458cb6682e20cc0bd3968d2b8233d406128156ff4eb63c07ffeeee30d7337ab4e583b4d6732ec390600307da4dda1ff01ffffffff02468c1b0000000000161455372fce5ae532ba82d57841c6c0509fcd32db75ac80a34cee00000000161418552af07934b3ff02aed2a5899d214cc55d5f89ac00000000"));
        assertTrue(tx2.getHash().equals(new Sha256Hash("636830cb48746d6fe52f2821b860b99dfb47adef171d11eba20d385656feedc3")));
        assertEquals(tx2.getHash(), txHashList.get(2));

        // A wallet which contains a pubkey used in each transaction from above
        KeyChainGroup group = new KeyChainGroup(unitTestParams);
        group.importKeys(ECKey.fromPublicOnly(HEX.decode("02f0df85e9c2d67a83146450431df90c7b26296ba5d7b6e0ea51c09326c11c48fd")),
//                         ECKey.fromPublicOnly(HEX.decode("04732012cb962afa90d31b25d8fb0e32c94e513ab7a17805c14ca4c3423e18b4fb5d0e676841733cb83abaf975845c9f6f2a8097b7d04f4908b18368d6fc2d68ec")),
                         ECKey.fromPublicOnly(HEX.decode("0271360b14755503d70ba7eab5c397d4e3b28ae6ae4a161531e7ef73fc398c5f8e")),
                         ECKey.fromPublicOnly(HEX.decode("02d2a8eb2c91ed95e5a3909e0ac560f55d05509102b14f3029c8c0e1714d4f6e7a")));
        Wallet wallet = new Wallet(unitTestParams, group);

        BloomFilter filter = wallet.getBloomFilter(wallet.getKeychainSize()*2, 0.001, 0xDEADBEEF);
        // Compare the serialized bloom filter to a known-good value
        assertTrue(Arrays.equals(filter.bitcoinSerialize(), HEX.decode("0a611cc99fecf74142798a09000000efbeadde02")));

        // Cheat and place the previous block (block 104593) at the head of the block store without supporting blocks
        blockStore = new MemoryBlockStore(UnitTestParams.get());
        blockStore.put(new StoredBlock(new Block(unitTestParams, HEX.decode("0200000024538d22a673b62aa131a484c13ef663ff9fa38242b92a073952fd703765d92a3d940fa492416272b37554075db1143ebcf1c96a7c8f5a55eb0dce45a9875460d0de4a5400000000ecc50a1d93980100181f0100d9b4fa4d5a5afed04d04509892ca886da9e661a507b0a4eb321b93e14a4fe7d71cf67578e30a9f4e1ff9cc8b96e988c63dff2b591ccaaad97f29b323e8093fd14fef9b96568a06c98581bb289c880d49f11f0ee6a77f34a884119ac768e09efffc0101000000010000000000000000000000000000000000000000000000000000000000000000ffffffff020101ffffffff019d87b226000000001614bcfd942ce6ece89ee98e62fc737fc74a869a0ec1ac00000000")),
                BigInteger.valueOf(1), 104593));
        blockStore.setChainHead(blockStore.get(new Sha256Hash("26149c9260e44a501d6903884f686e5c5d98ca4d6272397cb650907ae5556d19")));
        super.setUp(blockStore);
        
        peerGroup.addWallet(wallet);
        peerGroup.setUseLocalhostPeerWhenPossible(false); // Prevents from connecting to bitcoin nodes on localhost.

        blockChain.addWallet(wallet);

        peerGroup.startAsync();
        peerGroup.awaitRunning();

        // Create a peer.
        InboundMessageQueuer p1 = connectPeer(1);
        assertEquals(1, peerGroup.numConnectedPeers());
        // Send an inv for block 104594
        InventoryMessage inv = new InventoryMessage(unitTestParams);
        inv.addBlock(block);
        inbound(p1, inv);
        
        // Check that we properly requested the correct FilteredBlock
        Object getData = outbound(p1);
        assertTrue(getData instanceof GetDataMessage);
        assertTrue(((GetDataMessage)getData).getItems().size() == 1);
        assertTrue(((GetDataMessage)getData).getItems().get(0).hash.equals(block.getHash()));
        assertTrue(((GetDataMessage)getData).getItems().get(0).type == InventoryItem.Type.FilteredBlock);
        
        // Check that we then immediately pinged.
        Object ping = outbound(p1);
        assertTrue(ping instanceof Ping);
        
        // Respond with transactions and the filtered block
        inbound(p1, filteredBlock);
        inbound(p1, tx0);
        inbound(p1, tx1);
        inbound(p1, tx2);
        inbound(p1, new Pong(((Ping)ping).getNonce()));

        pingAndWait(p1);

        Set<Transaction> transactions = wallet.getTransactions(false);
        assertTrue(transactions.size() == 3);
        for (Transaction tx : transactions) {
            assertTrue(tx.getConfidence().getConfidenceType() == ConfidenceType.BUILDING);
            assertTrue(tx.getConfidence().getDepthInBlocks() == 1);
            assertTrue(tx.getAppearsInHashes().keySet().contains(block.getHash()));
            assertTrue(tx.getAppearsInHashes().size() == 1);
        }

        // Peer 1 goes away.
        closePeer(peerOf(p1));
        peerGroup.stopAsync();
        super.tearDown();
    }
}
